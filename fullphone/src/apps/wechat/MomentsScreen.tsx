import type { FC } from "react";
import { useEffect, useState } from "react";
import { useAiSettings } from "../../context/AiSettingsContext";
import { useWorldbook } from "../../context/WorldbookContext";
import { sendChatRequest } from "../../services/aiClient";
import type { ChatSettings } from "./ChatSettingsScreen";

interface MomentsScreenProps {
  onBack: () => void;
  onCharacterAction?: (action: "like" | "comment", momentId: string, content?: string) => void;
  filterChatId?: string; // å¯é€‰ï¼šåªæ˜¾ç¤ºç‰¹å®šè§’è‰²çš„æœ‹å‹åœˆ
}

export interface Moment {
  id: string;
  chatId: string; // å‘å¸ƒè¿™æ¡æœ‹å‹åœˆçš„è§’è‰²ID
  author: string;
  authorAvatar: string;
  content: string;
  images?: string[];
  timestamp: number; // å‘å¸ƒæ—¶é—´æˆ³
  time: string; // æ˜¾ç¤ºæ—¶é—´
  location?: string;
  likes: string[]; // ç‚¹èµçš„ç”¨æˆ·IDåˆ—è¡¨ï¼ˆ"ğŸ§¸"è¡¨ç¤ºç©å®¶ï¼‰
  comments: Comment[];
  autoGenerated?: boolean; // æ˜¯å¦ä¸ºAIè‡ªåŠ¨ç”Ÿæˆ
}

export interface Comment {
  id: string;
  author: string; // è¯„è®ºè€…IDï¼ˆ"ğŸ§¸"è¡¨ç¤ºç©å®¶ï¼‰
  content: string;
  replyTo?: string;
  timestamp: number;
}

const MOMENTS_STORAGE_KEY = "miniOtomePhone_moments";
const STORAGE_KEY_PREFIX = "miniOtomePhone_chatSettings_";
const MESSAGES_KEY_PREFIX = "miniOtomePhone_messages_";
const MOMENTS_COVER_KEY = "miniOtomePhone_momentsCover";

// æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
const formatTime = (timestamp: number): string => {
  const now = Date.now();
  const diff = now - timestamp;
  const minutes = Math.floor(diff / (1000 * 60));
  const hours = Math.floor(diff / (1000 * 60 * 60));
  const days = Math.floor(diff / (1000 * 60 * 60 * 24));

  if (minutes < 1) {
    return "åˆšåˆš";
  } else if (minutes < 60) {
    return `${minutes}åˆ†é’Ÿå‰`;
  } else if (hours < 24) {
    return `${hours}å°æ—¶å‰`;
  } else if (days === 1) {
    return "æ˜¨å¤©";
  } else if (days < 7) {
    return `${days}å¤©å‰`;
  } else {
    const date = new Date(timestamp);
    return date.toLocaleDateString("zh-CN", {
      month: "numeric",
      day: "numeric"
    });
  }
};

// ä»localStorageè¯»å–æœ‹å‹åœˆæ•°æ®
const loadMoments = (): Moment[] => {
  try {
    const stored = window.localStorage.getItem(MOMENTS_STORAGE_KEY);
    if (stored) {
      const moments: Moment[] = JSON.parse(stored);
      // æ›´æ–°æ˜¾ç¤ºæ—¶é—´
      return moments.map((moment) => ({
        ...moment,
        time: formatTime(moment.timestamp)
      }));
    }
  } catch {
    // ignore
  }
  return [];
};

// ä¿å­˜æœ‹å‹åœˆæ•°æ®åˆ°localStorage
const saveMoments = (moments: Moment[]) => {
  try {
    window.localStorage.setItem(MOMENTS_STORAGE_KEY, JSON.stringify(moments));
  } catch {
    // ignore
  }
};

export const MomentsScreen: FC<MomentsScreenProps> = ({ onBack, onCharacterAction, filterChatId }) => {
  const { aiConfig } = useAiSettings();
  const { config: worldbookConfig } = useWorldbook();
  const [moments, setMoments] = useState<Moment[]>(loadMoments());
  const [likedMoments, setLikedMoments] = useState<Set<string>>(new Set());
  const [showPublishModal, setShowPublishModal] = useState(false);
  const [publishContent, setPublishContent] = useState("");
  const [publishImages, setPublishImages] = useState<string[]>([]);
  const [publishLocation, setPublishLocation] = useState("");
  const [publishing, setPublishing] = useState(false);
  const [coverImage, setCoverImage] = useState<string>(() => {
    // ä»localStorageè¯»å–æœ‹å‹åœˆèƒŒæ™¯
    try {
      if (filterChatId) {
        // å¦‚æœæ˜¯æŸ¥çœ‹ç‰¹å®šè§’è‰²çš„æœ‹å‹åœˆï¼Œè¯»å–è¯¥è§’è‰²çš„èƒŒæ™¯å›¾
        const coverKey = `miniOtomePhone_momentsCover_${filterChatId}`;
        const stored = window.localStorage.getItem(coverKey);
        return stored || "";
      } else {
        // å¦‚æœæ˜¯æŸ¥çœ‹æ‰€æœ‰æœ‹å‹åœˆï¼Œè¯»å–å…¨å±€èƒŒæ™¯å›¾
        const stored = window.localStorage.getItem(MOMENTS_COVER_KEY);
        return stored || "";
      }
    } catch {
      return "";
    }
  });
  const [showCoverEdit, setShowCoverEdit] = useState(false);
  const [generatingMoment, setGeneratingMoment] = useState(false);
  const [characterSignature, setCharacterSignature] = useState<string>("");

  // å®šæœŸæ›´æ–°æ—¶é—´æ˜¾ç¤ºå’Œç›‘å¬æœ‹å‹åœˆæ›´æ–°
  useEffect(() => {
    const interval = setInterval(() => {
      setMoments((prev) =>
        prev.map((moment) => ({
          ...moment,
          time: formatTime(moment.timestamp)
        }))
      );
    }, 60000); // æ¯åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡

    // ç›‘å¬localStorageå˜åŒ–ï¼Œåˆ·æ–°æœ‹å‹åœˆæ•°æ®
    const handleStorageChange = () => {
      const updatedMoments = loadMoments();
      setMoments(updatedMoments);
    };

    // ç›‘å¬storageäº‹ä»¶ï¼ˆè·¨æ ‡ç­¾é¡µï¼‰
    window.addEventListener('storage', handleStorageChange);

    // å®šæœŸæ£€æŸ¥localStorageå˜åŒ–ï¼ˆåŒæ ‡ç­¾é¡µå†…æ›´æ–°ï¼‰
    const checkInterval = setInterval(() => {
      const currentMoments = loadMoments();
      const currentIds = currentMoments.map(m => m.id).sort().join(',');
      const stateIds = moments.map(m => m.id).sort().join(',');
      if (currentIds !== stateIds) {
        setMoments(currentMoments);
      }
    }, 1000); // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡

    return () => {
      clearInterval(interval);
      clearInterval(checkInterval);
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [moments]);

  // ä¿å­˜æœ‹å‹åœˆæ•°æ®
  useEffect(() => {
    saveMoments(moments);
  }, [moments]);

  // ä¿å­˜æœ‹å‹åœˆèƒŒæ™¯
  useEffect(() => {
    try {
      if (filterChatId) {
        // å¦‚æœæ˜¯ç‰¹å®šè§’è‰²çš„æœ‹å‹åœˆï¼Œä¿å­˜åˆ°è¯¥è§’è‰²çš„key
        const coverKey = `miniOtomePhone_momentsCover_${filterChatId}`;
        if (coverImage) {
          window.localStorage.setItem(coverKey, coverImage);
        } else {
          window.localStorage.removeItem(coverKey);
        }
      } else {
        // å¦‚æœæ˜¯å…¨å±€æœ‹å‹åœˆï¼Œä¿å­˜åˆ°å…¨å±€key
        if (coverImage) {
          window.localStorage.setItem(MOMENTS_COVER_KEY, coverImage);
        } else {
          window.localStorage.removeItem(MOMENTS_COVER_KEY);
        }
      }
    } catch {
      // ignore
    }
  }, [coverImage, filterChatId]);

  // è·å–è§’è‰²ä¿¡æ¯
  const getCharacterInfo = (chatId: string) => {
    try {
      const stored = window.localStorage.getItem(`${STORAGE_KEY_PREFIX}${chatId}`);
      if (stored) {
        const settings: ChatSettings = JSON.parse(stored);
        return {
          name: settings.nickname?.trim() || "ä»–/å¥¹",
          avatar: settings.avatar || "",
          emoji: "ğŸ©·",
          signature: settings.signature || ""
        };
      }
    } catch {
      // ignore
    }
    // é»˜è®¤å€¼
    return { name: "ä»–/å¥¹", avatar: "", emoji: "ğŸ©·", signature: "" };
  };

  // è¯»å–ä¸ªæ€§ç­¾åå¹¶ç›‘å¬æ›´æ–°
  useEffect(() => {
    if (!filterChatId) {
      setCharacterSignature("");
      return;
    }

    // ç«‹å³è¯»å–ä¸€æ¬¡
    const updateSignature = () => {
      try {
        const stored = window.localStorage.getItem(`${STORAGE_KEY_PREFIX}${filterChatId}`);
        if (stored) {
          const settings: ChatSettings = JSON.parse(stored);
          const newSignature = settings.signature || "";
          console.log("è¯»å–ä¸ªæ€§ç­¾å:", newSignature, "ä»chatId:", filterChatId);
          console.log("å®Œæ•´è®¾ç½®å¯¹è±¡:", JSON.stringify(settings));
          console.log("è®¾ç½®å¯¹è±¡ä¸­çš„signatureå­—æ®µ:", settings.signature);
          setCharacterSignature(newSignature);
        } else {
          console.log("æœªæ‰¾åˆ°ä¸ªæ€§ç­¾åæ•°æ®ï¼ŒchatId:", filterChatId);
          setCharacterSignature("");
        }
      } catch (e) {
        console.error("è¯»å–ä¸ªæ€§ç­¾åå¤±è´¥:", e);
        setCharacterSignature("");
      }
    };

    updateSignature();

    // ç›‘å¬è‡ªå®šä¹‰äº‹ä»¶ï¼ˆåŒæ ‡ç­¾é¡µå†…æ›´æ–°ï¼‰
    const handleSignatureUpdate = (e: Event) => {
      const customEvent = e as CustomEvent<{ chatId: string; signature: string }>;
      if (customEvent.detail?.chatId === filterChatId) {
        const newSignature = customEvent.detail.signature || "";
        console.log("æ”¶åˆ°ä¸ªæ€§ç­¾åæ›´æ–°äº‹ä»¶:", newSignature, "chatId:", filterChatId);
        setCharacterSignature(newSignature);
      }
    };
    window.addEventListener('signatureUpdated', handleSignatureUpdate);

    // ç›‘å¬storageäº‹ä»¶ï¼ˆè·¨æ ‡ç­¾é¡µï¼‰
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === `${STORAGE_KEY_PREFIX}${filterChatId}`) {
        console.log("æ”¶åˆ°storageäº‹ä»¶ï¼Œæ›´æ–°ä¸ªæ€§ç­¾å");
        updateSignature();
      }
    };
    window.addEventListener('storage', handleStorageChange);

    // å®šæœŸæ£€æŸ¥localStorageå˜åŒ–ï¼ˆåŒæ ‡ç­¾é¡µå†…æ›´æ–°ï¼Œä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆï¼‰
    const checkInterval = setInterval(() => {
      updateSignature();
    }, 300); // æ¯300æ¯«ç§’æ£€æŸ¥ä¸€æ¬¡ï¼Œæ›´é¢‘ç¹

    return () => {
      clearInterval(checkInterval);
      window.removeEventListener('storage', handleStorageChange);
      window.removeEventListener('signatureUpdated', handleSignatureUpdate);
    };
  }, [filterChatId]);

  // è¯»å–èŠå¤©è®°å½•ï¼ˆæœ€è¿‘20è½®å·¦å³ï¼‰
  const getRecentChatMessages = (chatId: string): Array<{ from: "me" | "ai"; content: string }> => {
    try {
      const stored = window.localStorage.getItem(`${MESSAGES_KEY_PREFIX}${chatId}`);
      if (stored) {
        const messages: Array<{ from: "me" | "ai"; content: string }> = JSON.parse(stored);
        // è¿”å›æœ€è¿‘20æ¡æ¶ˆæ¯ï¼ˆå¤§çº¦10è½®å¯¹è¯ï¼‰
        return messages.slice(-20);
      }
    } catch {
      // ignore
    }
    return [];
  };

  // è·å–ä¸–ç•Œä¹¦å†…å®¹
  const getWorldbookContent = (chatId: string): string => {
    if (!worldbookConfig) {
      return "";
    }

    // åˆå¹¶å…¨å±€å’Œåº”ç”¨ç‰¹å®šçš„ä¸–ç•Œä¹¦
    const allEntries = [
      ...(worldbookConfig.global || []),
      ...(worldbookConfig.perApp?.wechat || [])
    ];

    // è·å–è¯¥è§’è‰²ç›¸å…³çš„ä¸–ç•Œä¹¦æ¡ç›®
    const characterName = getCharacterInfo(chatId).name.toLowerCase();
    const relevantEntries = allEntries.filter((entry) => {
      // æ£€æŸ¥æ˜¯å¦ä¸è§’è‰²ç›¸å…³
      return entry.entries?.some((item) =>
        item.enabled !== false && (
          item.title.toLowerCase().includes(characterName) ||
          item.content.toLowerCase().includes(characterName) ||
          item.content.toLowerCase().includes(chatId.toLowerCase())
        )
      );
    });

    // åˆå¹¶ä¸–ç•Œä¹¦å†…å®¹
    return relevantEntries
      .map((entry) => {
        if (entry.entries && entry.entries.length > 0) {
          return entry.entries
            .filter((item) => item.enabled !== false)
            .map((item) => `[${item.title}]\n${item.content}`)
            .join("\n\n");
        }
        return "";
      })
      .filter(Boolean)
      .join("\n\n");
  };

  // ç”Ÿæˆä¸ªæ€§ç­¾å
  const generateSignature = async (chatId: string): Promise<string> => {
    try {
      const settings = getCharacterSettings(chatId);
      if (!settings) return "";

      const worldbookContent = getWorldbookContent(chatId);
      const recentMessages = getRecentChatMessages(chatId);

      // æ„å»ºæç¤ºè¯
      let prompt = `è¯·ä¸ºè¿™ä¸ªè§’è‰²ç”Ÿæˆä¸€ä¸ªç¬¦åˆäººè®¾çš„ä¸ªæ€§ç­¾åï¼ˆæœ‹å‹åœˆç­¾åï¼‰ï¼Œè¦æ±‚ï¼š
1. ç®€çŸ­ç²¾ç‚¼ï¼Œä¸è¶…è¿‡20ä¸ªå­—
2. ç¬¦åˆè§’è‰²çš„èº«ä»½ã€æ€§æ ¼å’ŒèŠå¤©é£æ ¼
3. å¯ä»¥æ˜¯å¿ƒæƒ…ã€æ€åº¦ã€åº§å³é“­ç­‰
4. **é‡è¦ï¼šå¿…é¡»åŸåˆ›ï¼Œç¦æ­¢ç…§æ¬ä»¥ä¸‹ç¤ºä¾‹ï¼Œåªèƒ½å‚è€ƒé£æ ¼**

å‚è€ƒé£æ ¼ç¤ºä¾‹ï¼ˆç¦æ­¢ç…§æ¬ï¼Œä»…ä½œé£æ ¼å‚è€ƒï¼‰ï¼š
- æŠ½è±¡æç¬‘ç‰ˆï¼šç²¾ç¥æ­£å¸¸ï¼Œå¶å°”å‘ç–¯ / è„‘å­ç¦»å®¶å‡ºèµ°ï¼Œèº«ä½“åŸåœ°æ‰“å·¥ / æ´»ç€å°±è¡Œï¼Œåˆ«æ¥æ²¾è¾¹
- æ—¥å¸¸ç¢ç¢å¿µç‰ˆï¼šå¥½å¥½åƒé¥­ï¼Œæ…¢æ…¢ç”Ÿæ´» / æ‘†çƒ‚ä¸­ï¼Œå¶å°”ç§¯æ / å¿«ä¹åŠ è½½ä¸­â€¦99%
- æ‘†çƒ‚ä½†é²œæ´»ç‰ˆï¼šæ‘¸é±¼ä¸ºä¸»ï¼Œå·¥ä½œä¸ºè¾… / èººå¹³ä¸æ‘†çƒ‚ï¼Œä½›ç³»ä¸èººèµ¢ / æ‰“å·¥å“ªæœ‰ä¸ç–¯çš„ï¼Œç¡¬æ’‘ç½¢äº†
- æ¸©æŸ”å°çœŸå®ç‰ˆï¼šæ—¥å­æ™®é€šï¼Œå¿«ä¹ä¸æ™®é€š / å¹³å®‰å°±å¥½ï¼Œå…¶ä½™éšç¼˜ / æ…¢æ…¢èµ°ï¼Œæ€»ä¼šæœ‰å…‰çš„
- éšæ€§å°è‡ªåœ¨ç‰ˆï¼šä¸æ…Œä¸å¿™ï¼Œåšè‡ªå·±çš„å…‰ / æˆ‘çš„ç”Ÿæ´»ï¼Œä¸ä½ æ— å…³ / éšå¿ƒèµ°ï¼Œåˆ«å›å¤´
- åƒè´§/æ‘†çƒ‚æ··æ­ç‰ˆï¼šå¹²é¥­ç§¯æï¼Œæ‰“å·¥éšæ„ / è„‘è¢‹ç©ºç©ºï¼Œè‚šå­èƒ–èƒ– / åƒå¥½å–å¥½ï¼Œé•¿ç”Ÿä¸è€

è§’è‰²ä¿¡æ¯ï¼š
- èº«ä»½ï¼š${settings.taIdentity || "æœªè®¾ç½®"}
- æ€§åˆ«ï¼š${settings.taGender || "æœªè®¾ç½®"}
- èŠå¤©é£æ ¼ï¼š${settings.chatStyle || "æœªè®¾ç½®"}
- å…¶ä»–ï¼š${settings.taOther || "æœªè®¾ç½®"}`;

      if (worldbookContent) {
        prompt += `\n\nä¸–ç•Œä¹¦è®¾å®šï¼š\n${worldbookContent}`;
      }

      if (recentMessages.length > 0) {
        prompt += `\n\næœ€è¿‘çš„èŠå¤©è®°å½•ï¼ˆå‚è€ƒè§’è‰²çš„è¯´è¯é£æ ¼ï¼‰ï¼š\n`;
        recentMessages.slice(-10).forEach((msg) => {
          prompt += `${msg.from === "me" ? "ç©å®¶" : "è§’è‰²"}: ${msg.content}\n`;
        });
      }

      prompt += `\n\nè¯·åªè¿”å›ä¸ªæ€§ç­¾åå†…å®¹ï¼Œä¸è¦åŒ…å«å…¶ä»–è§£é‡Šæ–‡å­—ã€‚`;

      const response = await sendChatRequest(
        aiConfig,
        [{ role: "user", content: prompt }]
      );

      if (response && response.trim()) {
        // æ¸…ç†å“åº”ï¼Œåªä¿ç•™ç­¾åå†…å®¹
        const signature = response.trim().replace(/^["']|["']$/g, "").slice(0, 20);
        return signature;
      }
    } catch (error) {
      console.error("ç”Ÿæˆä¸ªæ€§ç­¾åå¤±è´¥:", error);
    }
    return "";
  };

  // è·å–è§’è‰²è®¾ç½®
  const getCharacterSettings = (chatId: string): ChatSettings | null => {
    try {
      const stored = window.localStorage.getItem(`${STORAGE_KEY_PREFIX}${chatId}`);
      if (stored) {
        return JSON.parse(stored) as ChatSettings;
      }
    } catch {
      // ignore
    }
    return null;
  };

  // ç”Ÿæˆæœ‹å‹åœˆ
  const handleGenerateMoment = async () => {
    if (!filterChatId || generatingMoment) return;

    setGeneratingMoment(true);
    try {
      const settings = getCharacterSettings(filterChatId);
      if (!settings) {
        alert("æ— æ³•è·å–è§’è‰²ä¿¡æ¯");
        setGeneratingMoment(false);
        return;
      }

      const worldbookContent = getWorldbookContent(filterChatId);
      const recentMessages = getRecentChatMessages(filterChatId);
      const characterInfo = getCharacterInfo(filterChatId);

      // è¯»å–æœ€æ–°çš„ä¸ªæ€§ç­¾åï¼ˆä»localStorageç›´æ¥è¯»å–ï¼Œç¡®ä¿æ˜¯æœ€æ–°çš„ï¼‰
      let signature = characterInfo.signature;
      // å¦‚æœlocalStorageä¸­æœ‰æ›´æ–°çš„ç­¾åï¼Œä½¿ç”¨å®ƒ
      try {
        const latestStored = window.localStorage.getItem(`${STORAGE_KEY_PREFIX}${filterChatId}`);
        if (latestStored) {
          const latestSettings: ChatSettings = JSON.parse(latestStored);
          if (latestSettings.signature) {
            signature = latestSettings.signature;
            console.log("ä½¿ç”¨localStorageä¸­çš„æœ€æ–°ä¸ªæ€§ç­¾å:", signature);
          }
        }
      } catch (e) {
        console.error("è¯»å–æœ€æ–°ä¸ªæ€§ç­¾åå¤±è´¥:", e);
      }

      // å¦‚æœæ²¡æœ‰ä¸ªæ€§ç­¾åï¼Œå…ˆç”Ÿæˆä¸€ä¸ª
      if (!signature) {
        signature = await generateSignature(filterChatId);
        if (signature) {
          // ä¿å­˜ä¸ªæ€§ç­¾å - ä»localStorageè¯»å–æœ€æ–°è®¾ç½®ï¼Œç¡®ä¿ä¸ä¼šè¦†ç›–å…¶ä»–å­—æ®µ
          try {
            const latestStored = window.localStorage.getItem(`${STORAGE_KEY_PREFIX}${filterChatId}`);
            let updatedSettings: ChatSettings;

            if (latestStored) {
              // å¦‚æœlocalStorageä¸­æœ‰æ•°æ®ï¼Œä½¿ç”¨å®ƒä½œä¸ºåŸºç¡€
              const existingSettings: ChatSettings = JSON.parse(latestStored);
              updatedSettings = {
                ...existingSettings,
                signature // åªæ›´æ–°ç­¾åå­—æ®µ
              };
            } else {
              // å¦‚æœlocalStorageä¸­æ²¡æœ‰ï¼Œä½¿ç”¨settings
              updatedSettings = {
                ...settings,
                signature
              };
            }

            window.localStorage.setItem(
              `${STORAGE_KEY_PREFIX}${filterChatId}`,
              JSON.stringify(updatedSettings)
            );
            setCharacterSignature(signature);
            console.log("ç”Ÿæˆå¹¶ä¿å­˜ä¸ªæ€§ç­¾å:", signature);
          } catch (error) {
            console.error("ä¿å­˜ä¸ªæ€§ç­¾åå¤±è´¥:", error);
          }
        }
      }

      // æ„å»ºç”Ÿæˆæœ‹å‹åœˆçš„æç¤ºè¯
      let prompt = `è¯·ä¸ºè¿™ä¸ªè§’è‰²ç”Ÿæˆä¸€æ¡æœ‹å‹åœˆåŠ¨æ€ï¼Œè¦æ±‚ï¼š
1. å†…å®¹è¦ç¬¦åˆè§’è‰²çš„èº«ä»½ã€æ€§æ ¼å’ŒèŠå¤©é£æ ¼
2. å¯ä»¥æ˜¯æ—¥å¸¸åˆ†äº«ã€å¿ƒæƒ…ã€ç”Ÿæ´»ç‰‡æ®µç­‰
3. è¯­è¨€è‡ªç„¶ï¼Œç¬¦åˆæœ‹å‹åœˆçš„è¡¨è¾¾ä¹ æƒ¯
4. é•¿åº¦æ§åˆ¶åœ¨50å­—ä»¥å†…
5. åªè¿”å›æœ‹å‹åœˆå†…å®¹ï¼Œä¸è¦åŒ…å«å…¶ä»–è§£é‡Š

è§’è‰²ä¿¡æ¯ï¼š
- å§“åï¼š${characterInfo.name}
- èº«ä»½ï¼š${settings.taIdentity || "æœªè®¾ç½®"}
- æ€§åˆ«ï¼š${settings.taGender || "æœªè®¾ç½®"}
- èŠå¤©é£æ ¼ï¼š${settings.chatStyle || "æœªè®¾ç½®"}
- å…¶ä»–ï¼š${settings.taOther || "æœªè®¾ç½®"}`;

      if (worldbookContent) {
        prompt += `\n\nä¸–ç•Œä¹¦è®¾å®šï¼š\n${worldbookContent}`;
      }

      if (recentMessages.length > 0) {
        prompt += `\n\næœ€è¿‘çš„èŠå¤©è®°å½•ï¼ˆå‚è€ƒè§’è‰²çš„è¯´è¯é£æ ¼å’Œæœ€è¿‘çš„è¯é¢˜ï¼‰ï¼š\n`;
        recentMessages.forEach((msg) => {
          prompt += `${msg.from === "me" ? "ç©å®¶" : "è§’è‰²"}: ${msg.content}\n`;
        });
      }

      prompt += `\n\nè¯·åªè¿”å›æœ‹å‹åœˆå†…å®¹ï¼Œä¸è¦åŒ…å«å…¶ä»–è§£é‡Šæ–‡å­—ã€‚`;

      const response = await sendChatRequest(
        aiConfig,
        [{ role: "user", content: prompt }]
      );

      if (response && response.trim()) {
        // æ¸…ç†å“åº”
        const content = response.trim().replace(/^["']|["']$/g, "");

        // åˆ›å»ºæœ‹å‹åœˆåŠ¨æ€
        const newMoment: Moment = {
          id: `moment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          chatId: filterChatId,
          author: characterInfo.name,
          authorAvatar: characterInfo.avatar || characterInfo.emoji,
          content: content,
          timestamp: Date.now(),
          time: formatTime(Date.now()),
          likes: [],
          comments: [],
          autoGenerated: true
        };

        // ä¿å­˜åˆ°æœ‹å‹åœˆåˆ—è¡¨
        const updatedMoments = [...moments, newMoment];
        setMoments(updatedMoments);
        saveMoments(updatedMoments);
      } else {
        alert("ç”Ÿæˆæœ‹å‹åœˆå¤±è´¥ï¼Œè¯·é‡è¯•");
      }
    } catch (error) {
      console.error("ç”Ÿæˆæœ‹å‹åœˆå¤±è´¥:", error);
      alert("ç”Ÿæˆæœ‹å‹åœˆå¤±è´¥ï¼Œè¯·é‡è¯•");
    } finally {
      setGeneratingMoment(false);
    }
  };

  const handleLike = async (momentId: string) => {
    const moment = moments.find((m) => m.id === momentId);
    if (!moment) return;

    const isLiked = likedMoments.has(momentId);

    setMoments((prev) =>
      prev.map((m) => {
        if (m.id === momentId) {
          if (isLiked) {
            // å–æ¶ˆç‚¹èµ
            setLikedMoments((prev) => {
              const newSet = new Set(prev);
              newSet.delete(momentId);
              return newSet;
            });
            return {
              ...m,
              likes: m.likes.filter((like) => like !== "ğŸ§¸")
            };
          } else {
            // ç‚¹èµ
            setLikedMoments((prev) => new Set(prev).add(momentId));
            const newLikes = [...m.likes, "ğŸ§¸"];

            // å¦‚æœè¿™æ˜¯è§’è‰²å‘å¸ƒçš„æœ‹å‹åœˆï¼Œè§¦å‘è§’è‰²ååº”
            if (m.chatId && m.chatId !== "ğŸ§¸" && onCharacterAction) {
              onCharacterAction("like", momentId);
            }

            return {
              ...m,
              likes: newLikes
            };
          }
        }
        return m;
      })
    );
  };

  const handleComment = async (momentId: string, content: string) => {
    if (!content.trim()) return;

    const moment = moments.find((m) => m.id === momentId);
    if (!moment) return;

    // ç©å®¶è¯„è®ºæŒ‰åŸæ ·å‘é€/ä¿å­˜ï¼Œä¸è‡ªåŠ¨è¿½åŠ å†’å·
    const commentContent = content.trim();

    const newComment: Comment = {
      id: `c${Date.now()}`,
      author: "ğŸ§¸",
      content: commentContent,
      timestamp: Date.now()
    };

    setMoments((prev) =>
      prev.map((m) => {
        if (m.id === momentId) {
          const updated = {
            ...m,
            comments: [...m.comments, newComment]
          };

          // å¦‚æœè¿™æ˜¯è§’è‰²å‘å¸ƒçš„æœ‹å‹åœˆï¼Œè§¦å‘è§’è‰²ååº”
          if (m.chatId && m.chatId !== "ğŸ§¸" && onCharacterAction) {
            onCharacterAction("comment", momentId, content.trim());
          }

          return updated;
        }
        return m;
      })
    );
  };

  // å‘å¸ƒæœ‹å‹åœˆ
  const handlePublish = async () => {
    if (!publishContent.trim() && publishImages.length === 0) {
      alert("è¯·è¾“å…¥å†…å®¹æˆ–æ·»åŠ å›¾ç‰‡");
      return;
    }

    setPublishing(true);
    try {
      const newMoment: Moment = {
        id: `moment_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
        chatId: "ğŸ§¸", // ç©å®¶å‘å¸ƒ
        author: "æˆ‘",
        authorAvatar: "ğŸ§¸",
        content: publishContent.trim(),
        images: publishImages.length > 0 ? publishImages : undefined,
        timestamp: Date.now(),
        time: "åˆšåˆš",
        location: publishLocation.trim() || undefined,
        likes: [],
        comments: [],
        autoGenerated: false
      };

      const updatedMoments = [...moments, newMoment];
      setMoments(updatedMoments);
      saveMoments(updatedMoments);

      // æ¸…ç©ºè¡¨å•
      setPublishContent("");
      setPublishImages([]);
      setPublishLocation("");
      setShowPublishModal(false);

      // é€šçŸ¥çˆ¶ç»„ä»¶ç©å®¶å‘å¸ƒäº†æœ‹å‹åœˆ
      if (onCharacterAction) {
        // å»¶è¿Ÿè§¦å‘ï¼Œè®©æœ‹å‹åœˆå…ˆä¿å­˜
        setTimeout(() => {
          onCharacterAction("comment", newMoment.id, publishContent.trim());
        }, 500);
      }
    } catch (err) {
      console.error("å‘å¸ƒæœ‹å‹åœˆå¤±è´¥:", err);
      alert("å‘å¸ƒå¤±è´¥ï¼Œè¯·é‡è¯•");
    } finally {
      setPublishing(false);
    }
  };

  // å¤„ç†å›¾ç‰‡ä¸Šä¼ 
  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files) return;

    const newImages: string[] = [];
    const maxImages = 9;
    const remainingSlots = maxImages - publishImages.length;

    Array.from(files).slice(0, remainingSlots).forEach((file) => {
      if (file.size > 5 * 1024 * 1024) {
        alert(`å›¾ç‰‡ ${file.name} å¤§å°è¶…è¿‡5MBï¼Œå·²è·³è¿‡`);
        return;
      }

      const reader = new FileReader();
      reader.onload = (event) => {
        const result = event.target?.result;
        if (typeof result === "string") {
          newImages.push(result);
          if (newImages.length === Math.min(files.length, remainingSlots)) {
            setPublishImages((prev) => [...prev, ...newImages]);
          }
        }
      };
      reader.readAsDataURL(file);
    });
  };

  // ç§»é™¤å›¾ç‰‡
  const handleRemoveImage = (index: number) => {
    setPublishImages((prev) => prev.filter((_, i) => i !== index));
  };

  // æŒ‰æ—¶é—´å€’åºæ’åˆ—ï¼Œå¦‚æœæŒ‡å®šäº† filterChatIdï¼Œåˆ™åªæ˜¾ç¤ºè¯¥è§’è‰²çš„æœ‹å‹åœˆ
  const filteredMoments = filterChatId
    ? moments.filter((m) => m.chatId === filterChatId)
    : moments;
  const sortedMoments = [...filteredMoments].sort((a, b) => b.timestamp - a.timestamp);

  return (
    <div className="wechat-screen moments-screen">
      <header className="wechat-header moments-header">
        <button type="button" className="wechat-back-btn" onClick={onBack}>
          {filterChatId ? "â€¹ è¿”å›" : "â€¹ å‘ç°"}
        </button>
        <div className="wechat-title">
          <div className="wechat-title-main">
            {filterChatId ? getCharacterInfo(filterChatId).name + "çš„æœ‹å‹åœˆ" : "æœ‹å‹åœˆ"}
          </div>
        </div>
        {!filterChatId && (
          <button
            type="button"
            className="moments-camera-btn"
            title="å‘å¸ƒæœ‹å‹åœˆ"
            onClick={() => setShowPublishModal(true)}
          >
            ğŸ“·
          </button>
        )}
        {filterChatId && (
          <button
            type="button"
            className="moments-generate-btn"
            title="ç”Ÿæˆæœ‹å‹åœˆ"
            onClick={handleGenerateMoment}
            disabled={generatingMoment}
          >
            {generatingMoment ? "ç”Ÿæˆä¸­..." : "âœ¨"}
          </button>
        )}
      </header>

      <main className="moments-body">
        {/* é¡¶éƒ¨å°é¢å’Œç”¨æˆ·ä¿¡æ¯ */}
        <div className="moments-profile">
          <div
            className="moments-cover"
            onClick={filterChatId ? undefined : () => setShowCoverEdit(true)}
            style={{ cursor: filterChatId ? "default" : "pointer", position: "relative" }}
          >
            <div
              className="moments-cover-image"
              style={{
                backgroundImage: coverImage ? `url(${coverImage})` : undefined,
                backgroundSize: "cover",
                backgroundPosition: "center",
                backgroundRepeat: "no-repeat"
              }}
            >
              {!coverImage && !filterChatId && (
                <div style={{
                  position: "absolute",
                  top: "50%",
                  left: "50%",
                  transform: "translate(-50%, -50%)",
                  fontSize: "14px",
                  color: "rgba(255, 255, 255, 0.7)",
                  textAlign: "center",
                  pointerEvents: "none"
                }}>
                  ç‚¹å‡»æ›´æ¢èƒŒæ™¯
                </div>
              )}
            </div>
          </div>
          {/* ç”¨æˆ·ä¿¡æ¯æ˜¾ç¤ºåœ¨å³ä¾§åˆ†å‰²çº¿ä¸Š */}
          <div className="moments-user-info">
            <div className="moments-user-info-content">
              <div className="moments-user-name">
                {filterChatId
                  ? getCharacterInfo(filterChatId).name
                  : (() => {
                    try {
                      const stored = window.localStorage.getItem("miniOtomePhone_userNickname");
                      return stored || "æˆ‘";
                    } catch {
                      return "æˆ‘";
                    }
                  })()
                }
              </div>
              <div className="moments-user-avatar-wrapper">
                <div className="moments-user-avatar">
                  {filterChatId ? (() => {
                    const characterInfo = getCharacterInfo(filterChatId);
                    if (characterInfo.avatar) {
                      return (
                        <img
                          src={characterInfo.avatar}
                          alt={characterInfo.name}
                          style={{
                            width: "100%",
                            height: "100%",
                            objectFit: "cover",
                            borderRadius: "12px"
                          }}
                          onError={(e) => {
                            const target = e.target as HTMLImageElement;
                            target.style.display = "none";
                            const parent = target.parentElement;
                            if (parent && !parent.querySelector("span")) {
                              const span = document.createElement("span");
                              span.textContent = characterInfo.emoji;
                              parent.appendChild(span);
                            }
                          }}
                        />
                      );
                    }
                    return <span>{characterInfo.emoji}</span>;
                  })() : (() => {
                    try {
                      const stored = window.localStorage.getItem("miniOtomePhone_userAvatar");
                      const avatar = stored || "";
                      if (avatar) {
                        return (
                          <img
                            src={avatar}
                            alt="æˆ‘çš„å¤´åƒ"
                            style={{
                              width: "100%",
                              height: "100%",
                              objectFit: "cover",
                              borderRadius: "12px"
                            }}
                            onError={(e) => {
                              const target = e.target as HTMLImageElement;
                              target.style.display = "none";
                              const parent = target.parentElement;
                              if (parent && !parent.querySelector("span")) {
                                const span = document.createElement("span");
                                span.textContent = "ğŸ§¸";
                                parent.appendChild(span);
                              }
                            }}
                          />
                        );
                      }
                    } catch {
                      // ignore
                    }
                    return <span>ğŸ§¸</span>;
                  })()}
                </div>
                {filterChatId && characterSignature && (
                  <div className="moments-user-signature">
                    {characterSignature}
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* æœ‹å‹åœˆåŠ¨æ€åˆ—è¡¨ */}
        <div className="moments-list">
          {sortedMoments.length === 0 ? (
            <div className="moments-empty">
              <div className="moments-empty-text">è¿˜æ²¡æœ‰æœ‹å‹åœˆåŠ¨æ€</div>
              <div className="moments-empty-hint">
                {filterChatId
                  ? "è¯¥è§’è‰²è¿˜æ²¡æœ‰å‘å¸ƒè¿‡æœ‹å‹åœˆ"
                  : "è§’è‰²ä¼šæ ¹æ®èŠå¤©å†…å®¹è‡ªåŠ¨å‘å¸ƒæœ‹å‹åœˆå“¦ï½"
                }
              </div>
            </div>
          ) : (
            sortedMoments.map((moment) => {
              const characterInfo = getCharacterInfo(moment.chatId);
              return (
                <div key={moment.id} className="moments-item">
                  <div className="moments-item-avatar">
                    {characterInfo.avatar ? (
                      <img
                        src={characterInfo.avatar}
                        alt={characterInfo.name}
                        style={{
                          width: "100%",
                          height: "100%",
                          objectFit: "cover",
                          borderRadius: "6px"
                        }}
                        onError={(e) => {
                          // å¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œæ˜¾ç¤ºé»˜è®¤emoji
                          const target = e.target as HTMLImageElement;
                          target.style.display = "none";
                          const parent = target.parentElement;
                          if (parent && !parent.querySelector("span")) {
                            const span = document.createElement("span");
                            span.textContent = moment.authorAvatar || characterInfo.emoji;
                            parent.appendChild(span);
                          }
                        }}
                      />
                    ) : (
                      <span>{moment.authorAvatar || characterInfo.emoji}</span>
                    )}
                  </div>
                  <div className="moments-item-content">
                    <div className="moments-item-header">
                      <span className="moments-item-author">{moment.author}</span>
                    </div>
                    <div className="moments-item-text">{moment.content}</div>
                    {moment.images && moment.images.length > 0 && (
                      <div className="moments-item-images">
                        {moment.images.map((img, idx) => (
                          <div key={idx} className="moments-item-image">
                            {img && (img.startsWith("data:") || img.startsWith("http://") || img.startsWith("https://")) ? (
                              <img src={img} alt="" onError={(e) => {
                                const target = e.target as HTMLImageElement;
                                target.style.display = "none";
                              }} />
                            ) : (
                              <div style={{
                                width: "100%",
                                height: "100%",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                background: "#f0f0f0",
                                color: "#999",
                                fontSize: "12px"
                              }}>
                                å›¾ç‰‡åŠ è½½å¤±è´¥
                              </div>
                            )}
                          </div>
                        ))}
                      </div>
                    )}
                    <div className="moments-item-meta">
                      <span className="moments-item-time">{moment.time}</span>
                      {moment.location && (
                        <span className="moments-item-location">ğŸ“ {moment.location}</span>
                      )}
                    </div>
                    {(moment.likes.length > 0 || moment.comments.length > 0) && (
                      <div className="moments-item-interactions">
                        {moment.likes.length > 0 && (
                          <div className="moments-likes">
                            <span className="moments-likes-icon">â¤ï¸</span>
                            <span className="moments-likes-users">
                              {moment.likes.join(" ")}
                            </span>
                          </div>
                        )}
                        {moment.comments.length > 0 && (
                          <div className="moments-comments">
                            {moment.comments.map((comment) => {
                              // è§£æè¯„è®ºæ ¼å¼ï¼šè§’è‰²å¤‡æ³¨ å›å¤ ç©å®¶æ˜µç§°ï¼šå›å¤å†…å®¹
                              const isPlayerComment = comment.author === "ğŸ§¸";
                              const content = comment.content;

                              // æ£€æŸ¥æ˜¯å¦æ˜¯è§’è‰²å›å¤æ ¼å¼ï¼ˆåŒ…å«"å›å¤"å…³é”®å­—ï¼‰
                              const replyMatch = content.match(/^(.+?)\s+å›å¤\s+(.+?)ï¼š(.+)$/);

                              if (replyMatch && !isPlayerComment) {
                                // è§’è‰²å›å¤æ ¼å¼
                                const [, characterName, playerName, replyContent] = replyMatch;
                                return (
                                  <div key={comment.id} className="moments-comment">
                                    <span className="moments-comment-author">{characterName}</span>
                                    <span className="moments-comment-reply" style={{ color: "#576b95", margin: "0 4px" }}>å›å¤</span>
                                    <span className="moments-comment-author" style={{ marginRight: "4px" }}>{playerName}</span>
                                    <span style={{ marginRight: "4px" }}>ï¼š</span>
                                    <span className="moments-comment-content">{replyContent}</span>
                                  </div>
                                );
                              } else {
                                // æ™®é€šè¯„è®ºæ ¼å¼ï¼ˆç©å®¶è¯„è®ºæˆ–æ—§æ ¼å¼çš„è§’è‰²è¯„è®ºï¼‰
                                return (
                                  <div key={comment.id} className="moments-comment">
                                    <span className="moments-comment-author">
                                      {isPlayerComment ? "æˆ‘" : comment.author}
                                    </span>
                                    {isPlayerComment ? (
                                      <>
                                        {" "}
                                        <span className="moments-comment-content">{content}</span>
                                      </>
                                    ) : (
                                      <>
                                        <span style={{ marginRight: "4px" }}>ï¼š</span>
                                        <span className="moments-comment-content">{content}</span>
                                      </>
                                    )}
                                  </div>
                                );
                              }
                            })}
                          </div>
                        )}
                      </div>
                    )}
                    <div className="moments-item-actions">
                      <button
                        type="button"
                        className={`moments-action-btn ${likedMoments.has(moment.id) ? "moments-action-btn-liked" : ""}`}
                        onClick={() => handleLike(moment.id)}
                      >
                        {likedMoments.has(moment.id) ? "â¤ï¸ å·²èµ" : "ğŸ¤ èµ"}
                      </button>
                      <button
                        type="button"
                        className="moments-action-btn"
                        onClick={() => {
                          const content = prompt("è¾“å…¥è¯„è®ºï¼š");
                          if (content) {
                            handleComment(moment.id, content);
                          }
                        }}
                      >
                        ğŸ’¬ è¯„è®º
                      </button>
                    </div>
                  </div>
                </div>
              );
            })
          )}
        </div>
      </main>

      {/* å‘å¸ƒæœ‹å‹åœˆå¼¹çª— */}
      {showPublishModal && (
        <div className="settings-modal-backdrop" onClick={() => !publishing && setShowPublishModal(false)}>
          <div
            className="settings-modal-card"
            onClick={(e) => e.stopPropagation()}
            style={{ maxWidth: "500px", maxHeight: "80vh", overflowY: "auto" }}
          >
            <div className="settings-modal-title">å‘å¸ƒæœ‹å‹åœˆ</div>
            <div className="settings-modal-message" style={{ padding: "16px 0" }}>
              <div className="settings-field">
                <textarea
                  className="settings-textarea"
                  placeholder="åˆ†äº«ä½ çš„ç”Ÿæ´»..."
                  value={publishContent}
                  onChange={(e) => setPublishContent(e.target.value)}
                  style={{ minHeight: "120px", fontSize: "15px" }}
                  maxLength={500}
                />
                <div style={{ fontSize: "12px", color: "var(--text-sub)", textAlign: "right", marginTop: "4px" }}>
                  {publishContent.length}/500
                </div>
              </div>

              {/* å›¾ç‰‡é¢„è§ˆ */}
              {publishImages.length > 0 && (
                <div className="moments-publish-images">
                  {publishImages.map((img, idx) => (
                    <div key={idx} className="moments-publish-image-item">
                      <img src={img} alt={`é¢„è§ˆ ${idx + 1}`} />
                      <button
                        type="button"
                        className="moments-publish-image-remove"
                        onClick={() => handleRemoveImage(idx)}
                      >
                        Ã—
                      </button>
                    </div>
                  ))}
                </div>
              )}

              {/* æ·»åŠ å›¾ç‰‡æŒ‰é’® */}
              {publishImages.length < 9 && (
                <div className="settings-field">
                  <label
                    htmlFor="moments-image-upload"
                    className="soft-icon-btn"
                    style={{
                      display: "inline-block",
                      cursor: "pointer",
                      textAlign: "center",
                      padding: "8px 16px"
                    }}
                  >
                    ğŸ“· æ·»åŠ å›¾ç‰‡ ({publishImages.length}/9)
                  </label>
                  <input
                    id="moments-image-upload"
                    type="file"
                    accept="image/*"
                    multiple
                    style={{ display: "none" }}
                    onChange={handleImageUpload}
                  />
                </div>
              )}

              {/* ä½ç½®è¾“å…¥ */}
              <div className="settings-field">
                <input
                  className="settings-input"
                  placeholder="ğŸ“ æ·»åŠ ä½ç½®ï¼ˆå¯é€‰ï¼‰"
                  value={publishLocation}
                  onChange={(e) => setPublishLocation(e.target.value)}
                />
              </div>
            </div>
            <div style={{ display: "flex", gap: "8px", marginTop: "12px" }}>
              <button
                type="button"
                className="soft-icon-btn"
                onClick={() => {
                  if (!publishing) {
                    setShowPublishModal(false);
                    setPublishContent("");
                    setPublishImages([]);
                    setPublishLocation("");
                  }
                }}
                disabled={publishing}
                style={{ flex: 1 }}
              >
                å–æ¶ˆ
              </button>
              <button
                type="button"
                className="primary-pill-btn"
                onClick={handlePublish}
                disabled={publishing || (!publishContent.trim() && publishImages.length === 0)}
                style={{ flex: 1 }}
              >
                {publishing ? "å‘å¸ƒä¸­..." : "å‘å¸ƒ"}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* æ›´æ¢èƒŒæ™¯å¼¹çª— */}
      {showCoverEdit && (
        <div className="settings-modal-backdrop" onClick={() => setShowCoverEdit(false)}>
          <div
            className="settings-modal-card"
            onClick={(e) => e.stopPropagation()}
            style={{ maxWidth: "400px" }}
          >
            <div className="settings-modal-title">æ›´æ¢æœ‹å‹åœˆèƒŒæ™¯</div>
            <div className="settings-modal-message" style={{ padding: "16px 0" }}>
              <div className="settings-field">
                <label className="settings-label">èƒŒæ™¯é¢„è§ˆ</label>
                <div
                  style={{
                    width: "100%",
                    height: "200px",
                    borderRadius: "12px",
                    overflow: "hidden",
                    background: coverImage
                      ? `url(${coverImage})`
                      : "linear-gradient(135deg, var(--accent-pink-soft), var(--accent-lilac))",
                    backgroundSize: "cover",
                    backgroundPosition: "center",
                    backgroundRepeat: "no-repeat",
                    border: "2px solid rgba(255, 195, 224, 0.5)",
                    marginTop: "8px",
                    position: "relative"
                  }}
                >
                  {!coverImage && (
                    <div style={{
                      width: "100%",
                      height: "100%",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      color: "var(--text-sub)",
                      fontSize: "14px"
                    }}>
                      æš‚æ— èƒŒæ™¯
                    </div>
                  )}
                </div>
              </div>

              <div className="settings-field">
                <label
                  htmlFor="cover-image-upload"
                  className="primary-pill-btn"
                  style={{
                    display: "inline-block",
                    cursor: "pointer",
                    textAlign: "center",
                    padding: "8px 16px",
                    fontSize: "13px",
                    width: "100%",
                    marginTop: "8px"
                  }}
                >
                  é€‰æ‹©æœ¬åœ°å›¾ç‰‡
                </label>
                <input
                  id="cover-image-upload"
                  type="file"
                  accept="image/*"
                  style={{ display: "none" }}
                  onChange={(e) => {
                    const file = e.target.files?.[0];
                    if (file) {
                      if (file.size > 5 * 1024 * 1024) {
                        alert("å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡5MB");
                        return;
                      }
                      const reader = new FileReader();
                      reader.onload = (event) => {
                        const result = event.target?.result;
                        if (typeof result === "string") {
                          setCoverImage(result);
                        }
                      };
                      reader.readAsDataURL(file);
                    }
                  }}
                />
              </div>

              <div className="settings-field">
                <input
                  className="settings-input"
                  placeholder="æˆ–è¾“å…¥å›¾ç‰‡URLåœ°å€"
                  value={coverImage && !coverImage.startsWith("data:") ? coverImage : ""}
                  onChange={(e) => {
                    const url = e.target.value.trim();
                    if (url) {
                      setCoverImage(url);
                    } else {
                      setCoverImage("");
                    }
                  }}
                />
              </div>

              {coverImage && (
                <div className="settings-field">
                  <button
                    type="button"
                    className="soft-icon-btn"
                    onClick={() => setCoverImage("")}
                    style={{ width: "100%" }}
                  >
                    æ¸…é™¤èƒŒæ™¯
                  </button>
                </div>
              )}
            </div>
            <button
              type="button"
              className="primary-pill-btn settings-modal-btn"
              onClick={() => setShowCoverEdit(false)}
            >
              å®Œæˆ
            </button>
          </div>
        </div>
      )}
    </div>
  );
};
